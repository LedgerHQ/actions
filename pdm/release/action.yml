name: Release
description: |
  Bump version and publish release assets

  For JFrog Artifactory, repository needs to be authorized on Artifactory.
  Calling workflow need to have OIDC permissions:

  ```yaml
    permissions:
      id-token: write
  ```

inputs:
  kind:
    description: Kind of project to release (lib/app)
    required: true
    default: app
  pypi-token:
    description: A Token to publish on PyPI (private or public)
    required: false
    default: ""
  github-token:
    description: A Github token with
    required: true
  increment:
    description: "Kind of increment (optional: `MAJOR|MINOR|PATCH`)"
    required: false
  group:
    description: Dependency group(s) to install
    default: docs
  exclude-group:
    description: Dependency group(s) to exclude from install
    default: ''
  public:
    description: Is it a public library ?
    default: 'false'
  dgoss-args:
    description: "`dgoss` extra docker parameters"
    default: ""
  artifactory-repository:
    description: Artifactory repository to publish to (deprecated for `JFROG_REPOSITORY`)
    default: ""


outputs:
  url:
    description: The generated Github Release URL
    value: ${{ steps.release.outputs.url }}
  version:
    description: The released version
    value: ${{ steps.bump.outputs.version }}
  documentation:
    description: The released documentation URL
    value: ${{ steps.doc.outputs.url }}
  image:
    description: The released documentation URL
    value: ${{ steps.docker.outputs.image }}


runs:
  using: composite
  steps:
    - name: Handle deprecations
      run: |
        : Handle deprecations
        if [ "${{ inputs.artifactory-repository }}" != "" ]; then
          echo "‚ö†Ô∏è \`artifactory-repository\` input is deprecated, use the \`JFROG_REPOSITORY\` environment variable"
          echo "JFROG_REPOSITORY=${{ inputs.artifactory-repository }}" >> $GITHUB_ENV
        fi
      shell: bash
    - name: Clone and install dependencies
      uses: LedgerHQ/actions/pdm/init@main
      id: meta
      with:
        group: ${{ inputs.group }}
        exclude-group: ${{ inputs.exclude-group }}
        history: true
        github-token: ${{ inputs.github-token }}
        pypi-token: ${{ inputs.pypi-token }}
        python-version: "3.11"

    - name: Bump using commitizen
      id: bump
      run: |
        : Bump using commitizen
        CMD=('pdm' 'bump' '--changelog-to-stdout' '--git-output-to-stderr')
        if [[ $INPUT_INCREMENT ]]; then
          CMD+=('--increment' "$INPUT_INCREMENT")
        fi
        "${CMD[@]}" > body.md

        REV="$(pdm run cz version --project)"
        echo "REVISION=${REV}" >>"$GITHUB_ENV"
        echo "version=${REV}" >>"$GITHUB_OUTPUT"
      env:
        FORCE_COLOR: 'true'
        INPUT_INCREMENT: ${{ inputs.increment }}
      shell: bash

    # Build once to publish the same package on every repository
    - name: Build distribution
      if: inputs.kind == 'lib'
      run: |
        : Build distribution
        pdm build
      env:
        FORCE_COLOR: 'true'
      shell: bash

    ################################################################
    #                                                              #
    #                  üí• Side-effect zone üí•                      #
    #                                                              #
    # Successful actions will need cleanup üßπ in case of failure ! #
    #                                                              #
    ################################################################

    - name: Push to GemFury
      id: gemfury
      if: inputs.kind == 'lib' && inputs.public != 'true' && env.PDM_PUBLISH_USERNAME != null
      env:
        PDM_PUBLISH_REPO: https://push.fury.io/ledger
        PDM_PUBLISH_USERNAME: ${{ inputs.pypi-token }}
        PDM_PUBLISH_PASSWORD: "-" # tricks github actions YAML parser and PDM test for empty password
        FORCE_COLOR: 'true'
      run: |
        : Push to GenFury
        pdm publish --no-build
      shell: bash

    - name: Login to JFrog Ledger
      if: inputs.kind == 'lib' && inputs.public != 'true'
      uses: LedgerHQ/actions-security/actions/jfrog-login@actions/jfrog-login-1

    - name: Push to our internal JFrog Artifactory
      id: artifactory
      if: inputs.kind == 'lib' && inputs.public != 'true' && env.JFROG_URL
      env:
        PDM_PUBLISH_REPO: ${{ env.JFROG_URL }}/artifactory/api/pypi/${{ env.JFROG_REPOSITORY }}
        PDM_PUBLISH_USERNAME: ${{ env.JFROG_USER }}
        PDM_PUBLISH_PASSWORD: ${{ env.JFROG_TOKEN }}
        FORCE_COLOR: 'true'
      run: |
        : Push to our internal JFrog Artifactory
        pdm publish --no-build
      shell: bash

    - name: Attest
      if: steps.artifactory.outcome == 'success'
      uses: LedgerHQ/actions-security/actions/attest@actions/attest-1
      with:
        subject-path: dist/*

    - name: Sign
      if: steps.artifactory.outcome == 'success'
      uses: LedgerHQ/actions-security/actions/sign-blob@actions/sign-blob-1
      with:
        path: dist/*

    - name: Push to PyPI
      id: pypi
      if: inputs.kind == 'lib' && inputs.public == 'true' && env.PDM_PUBLISH_PASSWORD != null
      env:
        PDM_PUBLISH_PASSWORD: ${{ inputs.pypi-token }}
        FORCE_COLOR: 'true'
      run: |
        : Push to PyPI
        pdm publish --no-build
      shell: bash

    - name: Docker image
      uses: LedgerHQ/actions/pdm/docker@main
      id: docker
      if: inputs.kind == 'app' && steps.meta.outputs.has_docker == 'true'
      with:
        clone: false
        version: ${{ env.REVISION }}
        pypi-token: ${{ inputs.pypi-token }}
        github-token: ${{ inputs.github-token }}
        dgoss-args: ${{ inputs.dgoss-args }}

    - name: Add Docker image to release body
      if: steps.docker.outputs.image
      continue-on-error: true  # Not critical
      run: |
        : Add Docker image to release body
        echo -e "\n**Docker image**: \`${{ steps.docker.outputs.image }}@${{ steps.docker.outputs.digest }}\`\n" >> body.md
      shell: bash

    - name: Documentation
      id: doc
      if: steps.meta.outputs.has_docs == 'true'
      continue-on-error: true  # Can be manually published after
      uses: LedgerHQ/actions/pdm/doc@main
      with:
        version: ${{ env.REVISION }}
        pypi-token: ${{ inputs.pypi-token }}
        openapi: ${{ inputs.kind == 'app' && steps.meta.outputs.has_openapi == 'true' }}
        site: true
        init: false

    - name: Add documentation URL to release body
      if: steps.doc.outputs.url
      continue-on-error: true  # Not critical
      run: |
        : Add documentation URL to release body
        echo -e "\n**Documentation**: <${{ steps.doc.outputs.url }}>\n" >> body.md
      shell: bash

    - name: Push release commit and tag
      id: tag
      run: |
        : Push release commit and tag
        git push -f
        git push -f origin ${{ env.REVISION }}
      shell: bash

    - name: Github Release
      id: release
      continue-on-error: true  # Can be manually published after
      uses: softprops/action-gh-release@v2
      with:
        body_path: "body.md"
        tag_name: ${{ env.REVISION }}
        token: ${{ inputs.github-token }}
        fail_on_unmatched_files: false
        files: |
          dist/*
          docs/openapi.yaml
          CHANGELOG.md

    - name: Publish summary
      continue-on-error: true
      run: |
        : Publish summary
        echo "üöÄ [Version ${{ env.REVISION }}](${{ steps.release.outputs.url }}) has been published" | tee -a $GITHUB_STEP_SUMMARY
      shell: bash

    #################################################################################################
    #                                                                                               #
    #                                     üßπ Cleanup actions üßπ                                     #
    #                                                                                               #
    # You must ensure workflow always reach this point in case of failure in the side-effect zone ! #
    #                                                                                               #
    #################################################################################################

    # Cleanup published artifacts if tag push failed
    - name: Show release failure in summary
      if: failure()
      run: |
        : Show release failure in summary
        echo "‚ùå Release ${REVISION} failed" | tee -a $GITHUB_STEP_SUMMARY
        echo "DIST=${{ steps.meta.outputs.identifier }}" >> $GITHUB_ENV
      shell: bash

    - name: Cleanup documentation
      # Runs on release failure if doc has been published
      if: failure() && steps.doc.outcome == 'success'
      run: |
        : Cleanup documentation
        pdm run mike delete --push ${REVISION}
        echo "üßπ Documentation for version ${REVISION} has been removed" | tee -a $GITHUB_STEP_SUMMARY
      shell: bash

    - name: Cleanup docker GHCR image
      # Runs on release failure if docker has been published
      if: failure() && steps.docker.outcome == 'success'
      run: |
        : Cleanup docker
        # See:
        #   - https://docs.github.com/en/rest/packages/packages#list-package-versions-for-a-package-owned-by-an-organization
        #   - https://docs.github.com/en/rest/packages/packages#delete-package-version-for-an-organization
        GHAPI=("gh" "api" "-H" "Accept: application/vnd.github+json" "-H" "X-GitHub-Api-Version: 2022-11-28")
        PKG='${{ github.event.repository.name }}'
        VERSIONS=$(${GHAPI[@]} /orgs/LedgerHQ/packages/container/${PKG}/versions)
        QUERY='.[] | select(.name == "${{ steps.docker.outputs.digest }}") | .id'
        VERSION_ID=$(echo ${VERSIONS} | jq --raw-output ${QUERY})
        ${GHAPI[@]} --method DELETE /orgs/LedgerHQ/packages/container/${PKG}/versions/${VERSION_ID}
        IMAGE='${{ steps.docker.outputs.image }}@${{ steps.docker.outputs.digest }}'
        echo "üßπ Docker image \`${IMAGE}\` has been deleted" | tee -a $GITHUB_STEP_SUMMARY
      shell: bash

    - name: Cleanup docker JFrog Artifactory image
      # Runs on release failure if docker has been published
      if: failure() && steps.docker.outcome == 'success' && env.JFROG_DOCKER_REPOSITORY
      run: |
        : Cleanup docker JFrog Artifactory image
        # See:
        #   - https://jfrog.com/help/r/jfrog-rest-apis/introduction-to-the-jfrog-platform-rest-apis
        #   - https://jfrog.com/help/r/jfrog-rest-apis/delete-item
        curl -X DELETE -u ${JFROG_USER}:${JFROG_TOKEN} ${JFROG_URL}/artifactory/${JFROG_DOCKER_REPOSITORY}/${DIST}/${REVISION}
        echo "üßπ Docker image \`${IMAGE}\` has been deleted" | tee -a $GITHUB_STEP_SUMMARY
        echo "üßπ Package \`${DIST}==${REVISION}\` have been deleted from JFrog Artifactory \`${JFROG_DOCKER_REPOSITORY}\` repository" | tee -a $GITHUB_STEP_SUMMARY
      shell: bash

    - name: Cleanup GemFury
      # Runs on release failure if package has been published to GemFury
      if: failure() && steps.gemfury.outcome == 'success'
      run: |
        : Cleanup GemFury
        # GemFury is unable to cleanup standard Python versions as it sees wheel+sdist
        # as 2 Python versions, but doesn't provide distinct kind for them.
        # So we delete by ID
        # See:
        #   - https://github.com/gemfury/cli/blob/main/api/yank.go
        #   - https://github.com/gemfury/cli/blob/main/api/client.go
        #   - https://github.com/gemfury/cli/blob/main/cli/yank.go
        FURY=(curl --no-progress-meter -H "Accept: application/vnd.fury.v1" -H "Authorization: ${{ inputs.pypi-token }}" https://api.fury.io)
        VERSIONS=$("${FURY[@]}/versions?name=${DIST}&version=${REVISION}")

        echo "$VERSIONS" | jq -c ".[]" | while read i; do
            filename=$(echo "$i" | jq -r .filename)
            version_id=$(echo "$i" | jq -r .id)
            package_id=$(echo "$i" | jq -r .package_id)
            "${FURY[@]}/packages/${package_id}/versions/${version_id}" -X DELETE > /dev/null
            echo "üßπ GemFury package \`${filename}\` have been deleted" | tee -a $GITHUB_STEP_SUMMARY
        done
      shell: bash

    - name: Cleanup JFrog Artifactory
      # Runs on release failure if package has been published to JFrog Artifactory
      if: failure() && steps.artifactory.outcome == 'success'
      run: |
        : Cleanup JFrog Artifactory
        # See:
        #   - https://jfrog.com/help/r/jfrog-rest-apis/introduction-to-the-jfrog-platform-rest-apis
        #   - https://jfrog.com/help/r/jfrog-rest-apis/delete-item
        curl -X DELETE -u ${JFROG_USER}:${JFROG_TOKEN} ${JFROG_URL}/artifactory/${JFROG_REPOSITORY}/${DIST}/${REVISION}
        echo "üßπ Package \`${DIST}==${REVISION}\` have been deleted from JFrog Artifactory \`${{ inputs.artifactory-repository }}\` repository" | tee -a $GITHUB_STEP_SUMMARY
      shell: bash

    - name: Cleanup PyPI
      # Runs on release failure if package has been published to PyPI
      if: failure() && steps.pypi.outcome == 'success'
      run: |
        : Cleanup PyPI
        # See: https://pypi.org/help/#file-name-reuse
        echo "‚ö†Ô∏è You need to manually delete [\`${DIST}==${REVISION}\` on PyPI](https://pypi.org/project/${DIST}/${REVISION}/)." | tee -a $GITHUB_STEP_SUMMARY
        echo "‚ö†Ô∏è The version is not usable anymore. See the [dedicated PyPI FAQ entry](https://pypi.org/help/#file-name-reuse)." | tee -a $GITHUB_STEP_SUMMARY
      shell: bash
