# more info on https://ledgerhq.atlassian.net/l/cp/Ar8F1nmM
name: 'Auto Cascade Merge'
description: 'Automatically cascade merge changes from one branch to others.'
branding:
  icon: 'git-pull-request'
  color: 'purple'

inputs:
  gh-token:
    description: 'pass GITHUB_TOKEN'
    required: true
  default-branch:
    description: 'Default branch name (e.g., main or master)'
    required: true
    default: 'main'
  auto-merge-pr:
    description: 'Whether to auto-merge the pull requests or not. true/false'
    required: true
    default: 'false'
  create-pr:
    description: '`true` to create PR or `false` to directly merge'
    required: true
    default: 'true'

runs:
  using: "composite"

  steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # fetch all history so we can push to other branches

    - name: Configure Git
      run: |
        git config user.name "GitHub Actions"
        git config user.email "github-actions@github.com"
      shell: bash

    - name: Install GH CLI
      uses: dev-hanz-ops/install-gh-cli-action@master

    - name: Skip cascade merge
      run: |
        function echo_green {
            echo -e "\e[32m$1\e[0m"
        }
        echo_green "The job was skipped because the commit message contains '[skip cascade merge]'"
      if: contains(env.COMMIT_MSG, '[skip cascade merge]')
      shell: bash
      env:
        COMMIT_MSG: ${{ github.event.head_commit.message }}

    - name: Create PR
      if: "! contains(env.COMMIT_MSG, '[skip cascade merge]')"  # continue only if the message does not contain '[skip cascade merge]'
      id: create_prs
      run: |
        # Enables the shell to print all executed commands and exit if any command fails
        set +e
        
        BACKPORT_TARGET_BRANCH_PATTERN="release/"
        ORIGINAL_BRANCH="${GITHUB_REF#refs/heads/}"
        ORIGINAL_VERSION="${ORIGINAL_BRANCH#"$BACKPORT_TARGET_BRANCH_PATTERN"}"
        RELEASE_VERSIONS=$(git branch -r | grep -oP "origin/${BACKPORT_TARGET_BRANCH_PATTERN}\\K.*" | sort -V)

        CURRENT_INDEX=$(echo $RELEASE_VERSIONS | tr ' ' '\n' | grep -n $ORIGINAL_VERSION | cut -d: -f1)
        LAST_INDEX=$(echo $RELEASE_VERSIONS | tr ' ' '\n' | wc -l)

        # if the commit is on a release branch, adjust the original branch for the next iteration
        if [[ $CURRENT_INDEX -ne "" ]]; then
          NEXT_INDEX=$((CURRENT_INDEX + 1))
          ORIGINAL_BRANCH="$BACKPORT_TARGET_BRANCH_PATTERN$(echo $RELEASE_VERSIONS | tr ' ' '\n' | sed -n "${NEXT_INDEX}p")"
        fi

        for i in $(seq $NEXT_INDEX 1 $LAST_INDEX); do
          CURRENT_TARGET_VERSION=$(echo $RELEASE_VERSIONS | tr ' ' '\n' | sed -n "${i}p")

          if [[ $i -eq $LAST_INDEX ]]; then
            CURRENT_TARGET_BRANCH="${{ inputs.default-branch }}"
          else
            CURRENT_TARGET_BRANCH="$BACKPORT_TARGET_BRANCH_PATTERN$CURRENT_TARGET_VERSION"
          fi

          git checkout $CURRENT_TARGET_BRANCH
          git pull origin $CURRENT_TARGET_BRANCH
          git merge --no-ff $ORIGINAL_BRANCH || { echo "Merge conflict detected, aborting"; exit 1; }
          git push origin $CURRENT_TARGET_BRANCH

          ORIGINAL_BRANCH=$CURRENT_TARGET_BRANCH
        done
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh-token }}
        COMMIT_MSG: ${{ github.event.head_commit.message }}
